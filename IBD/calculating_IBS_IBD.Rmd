---
title: "Calculating IBS & IBD"
author: "Nick Brazeau, Sophie Berube, Izzy Routledge, & Abebe Fola"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output:
  html_document:
    theme: readable
    highlight: tango
    code_folding: hide
    toc: yes
    toc_float:
      collapsed: no
      smooth_scroll: no
    toc_depth: 2
    number_sections: yes
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = T, warning = F, message = F,
                      fig.align = 'center', fig.keep = 'all')
```

<!-- Here we style out button a little bit -->

```{=html}
<style>
.showopt {
background-color: #004c93;
color: #FFFFFF;
width: 100px;
height: 20px;
text-align: center;
vertical-align: middle !important;
border-radius: 8px;
float:right;
}

.showopt:hover {
background-color: #dfe4f2;
color: #004c93;
}

</style>
```
<!--Include script for hiding output chunks-->

```{=html}
<script src="misc/hideOutput.js"></script>
```
# Dependencies for Practical {.unnumbered}

Please copy and paste the below code chunk in it's entirety to your console to download R package libraries needed for this practical. If you are having trouble installing any of the R packages, please ask an instructor for a pre-loaded flash drive.

```{r, echo=T}
deps <- c("tidyverse", "vcfR", "MIPanalyzer", "hmmibdr", "sf", "tidygraph", "ggraph")
deps <- !sapply(deps, function(x){x %in% installed.packages()[,1]} )
if(any(deps)) {
  if(deps["hmmibdr"]) {
    if (!"remotes" %in% installed.packages()[,1]){
      install.packages("remotes")
    }
    remotes::install_github("OJWatson/hmmibdr")
    deps <- deps[names(deps) != "hmmibdr"]
  } else if(deps["MIPanalyzer"]) {
    if (!"remotes" %in% installed.packages()[,1]){
      install.packages("remotes")
    }
    remotes::install_github("mrc-ide/MIPanalyzer")
    deps <- deps[names(deps) != "MIPanalyzer"]
  } else {
    install.packages(names(deps)[deps])
  }
}

```

Please now load all of those libraries into this session using the code chunk below. Please copy and paste it in its entirety.

```{r, echo=T}
library(tidyverse)
library(vcfR)
library(hmmibdr)
library(sf)
library(tidygraph)
library(ggraph)
library(cowplot)
```

Finally, please source (*i.e.* load) the file called `utils.r` that is stored under the `IBD/R` directory. If you are using the `IBD.Rproj` environment, you can just run `source("R/utils.R")` as below. Or if you are running from a different environment or working directory (`getwd()`), use the `file.choose` function to help locate the file.

```{r}
source("R/utils.R")
```

# Introduction
## Useful Definitions {.unnumbered}
_**Definition:** An allele is the state of a particular genetic locus or sequence that is inherited between parents and offspring._ <br>
_**Definition:** A locus is a fixed position on a chromosome where a particular genetic marker is located._ <br>
_**Definition:** Sequencing data consists of sequences of DNA obtained from a DNA sequencing reaction_ <br>
_**Definition:** Complexity of infection, or multiplicity of infection, is a measure of the number of different malaria parasite clones in an individual sample._ <br>
_**Definition:** A monoclonal malaria infection contains one parasite strain, or "genome" (complexity of infection [COI] = 1), while a polyclonal infection contains more than one parasite strain (COI > 1)._ <br>
_**Definition:** A deme is a local population that has individuals that interbreed and share genetic material._ <br>
<br>
<br>

## Relatedness Overview {.unnumbered}

During prior sessions, you have explored how to estimate relationships based on levels of population diversity, structure, and connectivity. In this practical, we will focus on between-parasite, or pairwise, measures of genetic relatedness. These are more "individual" focused measures of relatedness versus population, or deme, focused measures of relatedness.
<br>
There are two mains ways to estimate relatedness among individuals: identity by descent (IBD) or Time to Most Recent Common Ancestor (TMRCA) (see [Speed & Balding 2015](https://pubmed.ncbi.nlm.nih.gov/25404112/) for further discussion). We will be focusing on IBD, which leverages recombination to detect recent common inheritance of genetic material, or genetic relatedness.
<br>
Remember, that recombination and random segregation occurs with homologous chromosome pairing during the process of meiosis. This means that "maternal" and "paternal" genetic material is exchanged to create new "daughter" cells with unique genetic material (e.g. a new, unique haplotype).

<p align="center">
![](https://raw.githubusercontent.com/mrc-ide/AMMS2022/master/IBD/R_ignore/images/Meiosis.jpeg){height="300px"}
</p>


<br>
<br>

Applying this concept to malaria in the schematic below, a single mosquito has bitten two different individuals infected with a single strain of the malaria parasite, resulting in a superinfection. The two strains (red vs purple) then undergo recombination in the mosquito midgut and produce progeny that are siblings and expected to share half of their genomes on average. 
<br>
From a population genetics perspective, this exchange of genetic material via recombination can be leveraged to detect strong signals of genetic relatedness between individuals. For example, moving further along in the schematic, the mosquito bites three new hosts and transfers a new "daughter" parasites to the susceptible host respectively (*N.B.*, since only a single strain was transmitted, no cotransmission infections resulted despite the potential). The pedigree on the right shows two of the parasite siblings and highlights how much of their genome was inherited from the same parent in the same genomic location. 
<br> 
As a result, one way to conceptualize the genome is as blocks, or segments, that are joined together, where each block has its own unique ancestral history. We will explore the concept that as time increases, or there is an increasing number of generations generations, IBD blocks become smaller  (*i.e.* as the number of recombination events increases, blocks are broken into smaller and smaller bits).
<br>
<br>

<p align="center">
![](https://raw.githubusercontent.com/mrc-ide/AMMS2022/master/IBD/R_ignore/images/ibdsiblings.png){width="500px"}
</p>


<br>
<br>
<br>

## IBS/IBD Overview {.unnumbered}

As described in the lecture, we can consider pairwise relatedness by determining if the genetic sequence at a give position in the genome, a loci, between two parasites is identical (e.g. the same allele). We can either simply measure the number of sites with identical alleles between two individuals, termed identity by state (IBS), or, we can use statistical models to determine if identical alleles and "blocks" of the genome were likely to be inherited from a common ancestor, termed identity by descent (IBD). It is important to note the differences between IBS and IBD: IBS refers to the "state" or realization of the allele at a loci and can be the result of numerous factors other than ancestry (e.g. selection, drift, structure, chance). In contrast, IBD solely refers to inherited genetic material, which follow specific patterns relevant to public health that we will explore below. The differences between IBS and IBD are visualized in the schematic below, where sites may be IBS but not IBD, whilst all sites that are IBD are IBS.

<p align="center">
![](https://raw.githubusercontent.com/mrc-ide/AMMS2022/master/IBD/R_ignore/images/ibd_vs_ibs.png){width="300px"}
</p>

### IBState {.unnumbered}

Identity by state (IBS) is the proportion of identical loci divided by all measured loci in the genome between two parasites: $\mbox{parasite}_a$ and $\mbox{parasite}_b$, such that: $$IBS= \frac{\mbox{Shared loci}_{ab}}{\mbox{Number of loci}}$$

### IBDescent {.unnumbered}

Identity by Descent (IBD) is more complicated to calculate than IBS and requires statistical modeling in order to account for recombination and population allele frequencies. The most common statistical model used is called a Hidden Markov Model (see the *Further Reading* section for recommended sources).
<br>
<br>
_**Conceptual Question:** What are some reasons that parasite pairs may be IBS but not IBD? What is a method that you have already learned that would increase your suspicion for IBS but not IBD_
<br>
_**Answer:** Population allele frequencies (if an allele is very common or fixed in a population, it does not contain as much information to distinguish between IBD and IBS)_
<br>
<br>
_**Conceptual Question:** Are biallelic markers (genotypic positions with two alleles, or possibilities) or multiallelic markers (genotypic positions with multiple alleles) more informative for IBS/IBD. Would you suspect a site with 20 alleles to be identical by chance?_
<br>
_**Answer:** Multiallelic has more information_

### IBD Programs {.unnumbered}
<!-- https://www.tablesgenerator.com/markdown_tables -->
Below is a table of pros-cons-details of various IBD programs specified for malaria that have been peer-reviewed as of August 5, 2022. 
<br>
<br>
<br>

| **Program** 	| **Pros** 	| **Cons** 	| **Details** 	|
|---	|---	|---	|---	|
| [Inbreeding estimation](https://pubmed.ncbi.nlm.nih.gov/32355199/) 	| + Fast 	| + Assumes independent loci 	|  Model is not considering recombination blocks (backbone of IBD) 	|
| [hmmIBD](https://github.com/glipsnort/hmmIBD) 	| + Fast <br><br>+ Easy to use <br><br>+ Statistically robust <br><br>+ Cannonical program for malaria ibd <br> 	| + Specified for monoclonals 	|  Users can use in polyclonal samples, but is misspecified under model and results are typically conservative estimates of IBD 	|
| [isoRelate](https://github.com/bahlolab/isoRelate) 	| + Statistically robust <br><br>+ Handles polyclonals <br><br>+ Statistical testing for "important" loci <br> 	| + Can become computationally intensive  	|  Model assumes a "diploid" state for COI > 1, and thus makes a simplifying assumption about polyclonality 	|
| [DeploidIBD](https://github.com/DEploid-dev/DEploid) 	| + Statistically robust <br><br>+ Handles polyclonals <br><br>+ Phased sample results <br><br>+ Within-sample estimates of IBD <br> 	| + Computationally intensive 	| Model phases polyclonal samples into monoclonal samples (_i.e._ a sample with COI = 2 becomes two new phased strains: smpl1.1, smpl1.2). As part of phasing, program provides within-sample IBD. From phased sample results, users can use any existing IBD program (`hmmIBD`, `refinedIBD`, etc). Program's primary goal is phasing with within-IBD estimates provided as a "bonus". 	|

<br>
<br>

# Overview of Data {.unnumbered}
This data was simulated using a simple malaria model that takes into account spatial relationships, complexity of infection (COI), and population size under a Wright-Fisher model: [PolySimIBD](https://github.com/nickbrazeau/polySimIBD) - originally published in [Verity/Aydemir/Brazeau et al. 2020](https://pubmed.ncbi.nlm.nih.gov/32355199/). _Note_, the simulated data has a single chromosome  that is only 1,000 base pairs long (much smaller than malaria chromosomes) and as a result, has a much smaller recombination rate (relevant for `hmmIBD` input parameters.)
<br>
For this practical, we have simulated five populations, or demes: A-E. The demes were simulated to have the same number of people, or hosts; however, we have randomly selected five individuals from each deme to undergo molecular surveillance and be "sequenced" (_i.e._ in real life, you may select five participants from a village to donate whole-blood vs collecting blood from every individual in the village). The demes have varying intensity of transmission, or incidence, as indicated by the spectrum of yellow-red in the schematic legend. In addition, we expect for mosquitoes to migrate between the demes with respect to how far the demes are from each other (_i.e._ isolation by distance). Finally, we _hypothesize_ that the ocean between demes A-D and E is a barrier to any transmission from the "mainland" to the "island" (_i.e._ we expect mainland parasites to be distinct from island parasites). In summary, the data consists of:    

- Five demes (4 mainland, 1 island)   
- Locations are known for each deme    
- Five random samples from each deme
- Incidence as estimated by mean COI per deme\*

_\*As discussed yesterday, COI is a poor measure of incidence in the real world. For our model, it is quite correlated (in expectation) and will be used as a proxy here._
<br>

<p align="center">
![](https://raw.githubusercontent.com/mrc-ide/AMMS2022/master/IBD/R_ignore/images/sim_deme_schematic.png){width="500px"}
</p>

# Practical Goals {.unnumbered}

By the end of this practical, you should able to perform the below tasks and understand the following concepts:    
+ Calculate IBS
+ Calculate IBD 
+ IBS is straightforward to calculate but can produce biased estimates of relatedness (*i.e.* does not necessarily reflect ancestry and is affected by population level allele frequencies)   
+ IBD captures recent relatedness, useful for determining transmission events, transmission intensity, importation, and corridors of gene flow   
- Therefore, IBS/IBD can measure connectivity on spatial-temporal scales relevant to malaria control and elimination efforts      
+ IBD should decay with distance (isolation by distance) and time; when it does not, interesting things may be happening  

------------------------------------------------------------------------

# Importing Data

Here, we will use the `vcfR` [package](https://knausb.github.io/vcfR_documentation/) to read in our variant call file (VCF) that contains fifty biallelic SNPs for our twenty-five individuals across our five populations (A, B, C, D, E; *individuals named* A1-5, B1-5, ...).

Using the skills that you acquired yesterday, read in the VCF from our data folder that you downloaded from Github: `data/simulated_ibd.vcf.gz`. If you are having trouble locating the file on your computer, please type `file.choose` into your console for an interactive option to locate the file. Name the object (the vcf file you are reading in) "vcf" for simplicity.

```{r}
# participants DO NOT need to include the quiet bit
vcf <- quiet(vcfR::read.vcfR("data/simulated_ibd.vcf.gz"))
```

## Initial QC
As is always good practice, we can check our VCF for missing data and confirm it has the number of SNPs and samples that we expect. Explore the details and inner-workings of our new VCF to get a sense if it is trustworthy (_i.e._ does the data look reasonable? Is there anything strange in the INFO column?). 

_**Code Challenge:** Use the `extract.gt` function from the vcfR package to pull out the allele depth for the first record (referent allele) for your new VCF. Now plot that allele depth as an initial data exploration using the `heatmap.bp` function from the `vcfR` package to generate the figure below.

```{r}
ad <- vcfR::extract.gt(vcf, element = "AD", as.numeric = T)
vcfR::heatmap.bp(ad)
```

_**Conceptual Question:** Is above plot consistent w/ a high quality VCF? What are some questionable features?_
<br>
_**Answer:** While it does look high quality, there are several features that would make you question if it was real data:_    
- All of the REF/ALT basepair allele calls are "N" missing  
- All of the loci allele depths are 100  
- The QUALTIY column is all the same  
<br>
<br>
This data was simulated, and thus, lacks many of the "real world" appearances of a VCF generated from real sequencing data. It is always valuable to manually look at the VCF to determine if it's valid before starting analyses!
<br>

## Exploring Hets
Here, we will explore the number of heteerzygous genotype calls we have per sample in our VCF.
_**Code Challenge:** Again, use the `extract.gt` function from the vcfR package and pull out the genotype calls (`element = "GT"`) for all samples. Then wrangle the data into "long" format using `pivot` longer. Once you have "tidy long" data, calculate the mean heterozygosity per sample using the `summarise` function. 

```{r}
# extract and tidy
gt <- vcfR::extract.gt(vcf, element = "GT")
gt <- dplyr::bind_cols("chrom" = vcfR::getCHROM(vcf), "pos" = vcfR::getPOS(vcf), gt)
gt %>%
  tibble::as_tibble() %>%
  tidyr::pivot_longer(., cols = !c("chrom", "pos")) %>%
  dplyr::mutate(ishet = dplyr::case_when(value == "0/0" ~ F,
                                         value == "0/1" ~ T,
                                         value == "1/1" ~ F)) %>%
  dplyr::group_by(name) %>%
  dplyr::summarise(
    propHet = mean(ishet)) %>%
  ggplot() +
  geom_point(aes(x = name, y = propHet)) +
  ylab("Proportion of Sample that is Het") +
  xlab("") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, vjust = 0.75, hjust = 0.5))
```

_**Conceptual Question:** Do you recognize any pattern in heterozygote calls with respect to demes? How does this relate to the polyclonality lesson yesterday?_
<br>
_**Answer:** Demes with higher transmission intensity have more heterozygote calls_
<br>
<br>

# Intuition

## Visualizing Recombination

One approach of conceptualizing recombination is as a "stick breaking" process. For example, you can imagine that you have two sticks that are identical (_i.e._ twins, or clonal infections). In each new generation, you have to randomly break your stick at some point along its length. You then take your pieces of stick and flip a coin to determine if it will remain the same ("original") or inherit genetic material ("new"). Use the `view_recombo` (loaded from `R/utils.R`) function and explore the relationship between the number of generations, or time, and the length of recombination blocks that are IBD between the clones. 
<br>
For example, you could run the function with the following generational times (*unfold code chunk*).


```{r, eval=F}
view_recombo(generations_apart = 0)
view_recombo(generations_apart = 1)
view_recombo(generations_apart = 2)
view_recombo(generations_apart = 3)
view_recombo(generations_apart = 5)
view_recombo(generations_apart = 10)
view_recombo(generations_apart = 20)
```
<br>
<br>
_**Conceptual Question:** How does the amount of "clonal" genetic material change, or amount of the genome that is identical, change between the paired samples as we increase the number of generations that separates them? The figure below shows 20 generations of separation as a hint._
<br>
_**Answer:** Decreases_
<br>
```{r, echo=F}
view_recombo(generations_apart = 20) +
  labs(title = "Breakdown of Clonal Material \n over 20 Generations",
       caption = "Note, new material is not necessarily IBD")

```
<br>
<br>
<br>

# Calculations

### Internal Data Manipulation

Here, we are going to convert our _vcf_ object that we read in with the `vcfR` package to a _mip_ object in order to later use the [`MIPAnalyzer` Package](https://github.com/mrc-ide/MIPanalyzer/tree/master/R) and the maximum likelihood estimator of IBD from [Verity et al. 2020](https://pubmed.ncbi.nlm.nih.gov/32355199/). This is purely for convenience and is not changing the underlying data in the vcf.

```{r}
mipvcf <- MIPanalyzer::vcf2mipanalyzer_biallelic(vcfR = vcf)
```

## Identity by State
_**Code Challenge:**_ Pick two samples from your VCF and write your own function to calculate IBS between the pair. I recommend starting with the `vcfR` object (vs. newly created `mipanalyzer_biallelic` object) and using the `extract.gt` function from the vcfR package to pull out the genotype calls (`element = "GT"`) as above. Then subset the data to two samples and compare loci.
<br>
<br>
_**Example Answer:** (unfold code)_.
```{r, eval=F}
# pick two samples
simpleIBS <- function(vcfRobj, smpl1name, smpl2name) {
  # extract GT information from vcf
  gt <- vcfR::extract.gt(vcfRobj, element = "GT")
  # subset to our samples, these are now vectors
  smpl1 <- gt[,smpl1name]
  smpl2 <- gt[,smpl2name]
  # evaluate if each element in vector is the same or different = Boolean result
  # take mean to get a proportion (binomial mean)
  ibsprop <- mean(smpl1 == smpl2)
  return(ibsprop)
}

simpleIBS(vcfRobj = vcf, smpl1name = "A1", smpl2name = "D1")

```
<br>
<br>

### Run Package IBS
Next, we will use the IBS calculator from the `MIPAnalyzer` R package to calculate pairwise IBS for all combinations of samples in our simulated data. Please see the code below for ease of running the algorithm.  

```{r}
# get IBS
ibs <- MIPanalyzer::get_IBS_distance(x = mipvcf,
                                     ignore_het = FALSE,
                                     report_progress = FALSE)
```

#### Tidy Results
The function returns the data in a "wide" format or a [distance matrix](https://en.wikipedia.org/wiki/Distance_matrix). While this a perfectly acceptable format, it is not considered "tidy". 
_**Code Challenge**_: Wrangle the data into "long" format using `broom::tidy` function. Rename the columns for the long data to `c("p1", "p2", "ibsdist")`. Note, make sure to preserve the sample names from `colnames(vcf@gt)[2:ncol(vcf@gt)]` prior to tidying!
<br>
Below, we will explore our new tidy data! 

```{r}
# tidy result
colnames(ibs) <- rownames(ibs) <- colnames(vcf@gt)[2:ncol(vcf@gt)]

ibs_long <- broom::tidy(as.dist(ibs)) %>%  
  magrittr::set_colnames(c("p1", "p2", "ibsdist"))
```

#### Explore Results
It is always good practice to explore our results. Let's make a boxplot to explore the distribution of our calculated IBS results.
_**Code Challenge**_: Use the `geom_boxplot` ggplot layer to create a boxplot with IBS values on the y-axis. 
```{r}
# boxplot result
ibs_long %>%
  ggplot() +
  geom_boxplot(aes(y = ibsdist),
               outlier.colour = "red", outlier.shape=8,
               outlier.size=4) +
  ylab("IBS Values") +
  theme_bw() +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank())

```
_**Conceptual Question:** Describe the distribution. Is this what you expected?_
<br>
<br>
<br>

## Identity by Descent
In this section, we will use two different "aglorithms" to calculate IBD. The first will be a maximum likelihood estimator that calculates the amount of "inbreeding" which approximates IBD (see [Verity et al. 2020](https://pubmed.ncbi.nlm.nih.gov/33057671/) for a mathematical description). Next, we will use a hidden Markov model from the R-package `hmmIBDR`, which is a wrapper for the original `hmmIBD` algorithm (for a full mathematical description of `hmmIBD` see [Schaffner & Taylor 2018](https://pubmed.ncbi.nlm.nih.gov/29764422/)).

#### MLE IBD
As above, we will use `MIPAnalyzer` R package to calculate pairwise IBD for all combinations of samples in our simulated data. Please see the code below for ease of running the algorithm. We are then going to similarly tidy the data from "wide" to "long" format.
```{r}
#......................
# MLE IBD
#......................
ibd <- MIPanalyzer::inbreeding_mle(x = mipvcf,
                                   f = seq(0.01, 0.99, 0.01),
                                   ignore_het = FALSE,
                                   report_progress = FALSE)
```

<br>
_**Code Challenge**_: Let's now convert our data to "long" format again using the `broom::tidy` function. Make sure to set your diagonal to 1 (self comparisons), preserve the sample names, and name your columns `c("p1", "p2", "malecotf")`. 
```{r}
# tidy result
diag(ibd$mle) <- 1
colnames(ibd$mle) <- rownames(ibd$mle) <- colnames(vcf@gt)[2:ncol(vcf@gt)]

ibd_mle_long <- broom::tidy(as.dist(t(ibd$mle))) %>%  # note, mipanalyzer returns upper triangle
  magrittr::set_colnames(c("p1", "p2", "malecotf"))
```

#### Explore Results
We always explore our results! 
_**Code Challenge**_: Use the `geom_boxplot` ggplot layer to create a boxplot with IBD values on the y-axis.
```{r}
# boxplot result
ibd_mle_long %>%
  ggplot() +
  geom_boxplot(aes(y = malecotf),
               outlier.colour = "red", outlier.shape=8,
               outlier.size=4) +
  ylab("IBD MLE Values") +
  theme_bw() +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank())

```

_**Conceptual Question:** Describe the MLE distribution. Is this what you expected?_
<br>
<br>
<br>


#### IBD from HMM 
As stated above, we will use `hmmIBDR` R package [wrapper](https://github.com/OJWatson/hmmibdr) to calculate pairwise IBD. Please see the code belwo for ease of running the algorithm. Note, we are going to have to do some data munging and writing of input file in order to use the `hmmIBD` [program](https://github.com/glipsnort/hmmIBD).    
<br>

##### Formatting for `hmmIBD`
_**Code Challenge, part 1**_: Make a within-sample alternative allele frequency (WSAF) matrix. First, start by extracting the alternative allele, or the number of alternative reads, at a particular locus per sample using the `vcfR::extract.gt(vcf, element = "AD")` function: (the numerator). Next, calculate the total allele depth per locus, per sample using the `vcfR::extract.gt(vcf, element = "DP")` function: (the denominator). Now, find the WSAF by dividing the numerator by the denominator and name this new matrix `wsaf`. 

<br>

```{r}
#............................................................
# hmmIBD setup
#...........................................................
#......................
# part 1
#......................
# File of genotype data
ad <- vcfR::extract.gt(vcf, element = "AD")
dp <- vcfR::extract.gt(vcf, element = "DP", as.numeric = T)
altad <- vcfR::masplit(ad, record = 2, sort = F)
wsaf <- altad/dp
colnames(wsaf) <- colnames(vcf@gt)[2:ncol(vcf@gt)]
```

<br>
_**Code Challenge, part 2**_: Liftover this dataframe into a "`hmmIBD` compliant dataframe. First, add the chromosome and position to your wsaf matrix (as the first and second columns respectively) and name it `gtmat`. Then tidy your "wide" matrix to "long" format excluding the chromosome and position (*i.e.* we want a dataframe with chromosome, position, sample, wsaf as our columns) with the function: `tidyr::pivot_longer(., cols = !c("chrom", "pos"))`. We are now going to coerce are WSAF calculations into homozygous genotype calls using rounding: `gthmm = round(value, 0)`. In addition, make sure to drop the `value` column (now redundant) and for `hmmIBD` liftover the chromosome names to integers: (`chrom = 1)`. In a turn of events, we will now make our data "wide" from long and write out this new table to your local drive for `hmmIBD` using the functions: `tidyr::pivot_wider(data = ., names_from = "name", values_from = "gthmm")` and `readr::write_tsv(x = gtmat, file = "data/gt_matrix_for_hmmIBD.txt", col_names = T)`, respectively. 
<br>

```{r}
#......................
# part 2
#......................
gtmat <- dplyr::bind_cols("chrom" = vcfR::getCHROM(vcf), "pos" = vcfR::getPOS(vcf), wsaf)
gtmat <- gtmat %>%
  tidyr::pivot_longer(., cols = !c("chrom", "pos")) %>%
  dplyr::mutate(chrom = 1,
                gthmm = round(value, 0)) %>%
  dplyr::select(-c("value")) %>%
  tidyr::pivot_wider(data = ., names_from = "name", values_from = "gthmm")
readr::write_tsv(x = gtmat, file = "data/gt_matrix_for_hmmIBD.txt",
                 col_names = T)
```

<br>
_**Code Challenge, part 3**_: Calculate the PLAF. Finally, using your `wsaf` matrix, calculate the population level allele frequencies for each locus using the following function: `altafvec <- rowMeans(wsaf, na.rm = T)`. Remember, this is the alternative allele frequency, and because we are dealing with biallelic sites, we can calculate the referent allele frequency as 1-alt and place this all in a dataframe. The dataframe needs a chromosome column (as a numeric/integer [`chrom = 1`]), a column for locus' basepair position, a referent allele frequency column, and an alternative allele frequency column. Write this table out to your local drive with the following path: `data/af_matrix_for_hmmIBD.txt`.
<br>

```{r}
#......................
# part 3 
#......................
# File of allele frequencies for the sample population. Format: tab-delimited, no header, one variant per row. Line format: <chromosome (int)> <position (bp, int)> <allele 1 freq> <all 2 freq> [<all 3 freq>] ... The genotype and frequency files must contain exactly the same variants, in the same order. If no file is supplied, allele frequencies are calculated from the input data file.
altafvec <- rowMeans(wsaf, na.rm = T)
afmat <- dplyr::bind_cols("chrom" = vcfR::getCHROM(vcf),
                          "pos" = vcfR::getPOS(vcf),
                          1-altafvec, altafvec) %>%
  dplyr::mutate(chrom = 1)
readr::write_tsv(afmat, file = "data/af_matrix_for_hmmIBD.txt", col_names = F)
```
<br>
Explore the [hmmIBD documentation](https://github.com/glipsnort/hmmIBD) for a justification of this munging that we did above and further clarfication of the caveat below. 

_**Caveat**: The `hmmIBD` algorithm assumes that all samples are monoclonal. As a result, it does not accept heterozygote calls natively. As a user, we have two options: (1) to set those heterozygote calls to missing (a conservative approach), or (2) make a strong assumption about what a heterozygote call means (an aggressive approach). Here, I have forced the samples to be monoclonal by estimating their within-sample allele frequencies and rounding to the nearest variant._

<br>
<br>
<br>

##### Running hmmIBD 
Next, we will use the `hmmIBD` program to calculate pairwise IBD. For convenience, copy and paste the code below into your console to acquire these results. 

```{r}
#......................
# hmmIBD run
#......................
tf <- tempfile(pattern = "output_simdat")
out <- hmmibdr::hmm_ibd(input_file = "data/gt_matrix_for_hmmIBD.txt",
                        allele_freqs =  "data/af_matrix_for_hmmIBD.txt",
                        rec_rate = 1e-2, # note the small recombo rate relative to what would be expected in malaria
                        output_file = tf)

# hmmIBD tidy
ibd_hmm_long <- tibble::tibble(
  p1 = out$fract$sample1,
  p2 = out$fract$sample2,
  hmm = out$fract$fract_sites_IBD)


```

#### Explore Results
Again, we always explore our results! 
_**Code Challenge**_: Use the `geom_boxplot` ggplot layer to create a boxplot with IBD HMM values on the y-axis.
```{r}
# boxplot result
ibd_hmm_long %>%
  ggplot() +
  geom_boxplot(aes(y = hmm),
               outlier.colour = "red", outlier.shape=8,
               outlier.size=4) +
  ylab("IBD HMM Values") +
  theme_bw() +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank())

```

_**Conceptual Question:** Describe the HMM distribution. Is this what you expected?_
<br>
<br>

#### Contrast MLE vs HMM
Now, we will compare the MLE IBD vs the HMM IBD results.
_**Code Challenge**_: Use the `geom_point` ggplot layer to create a plot that contrast the two different calculations. You will need to join the data by sample using the following function: `left_join(ibd_mle_long, ibd_hmm_long, by = c("p1", "p2"))`.

```{r}
dplyr::left_join(ibd_mle_long, ibd_hmm_long, by = c("p1", "p2")) %>%
  ggplot() +
  geom_point(aes(x = hmm, y = malecotf)) +
  theme_bw() +
  labs(x = "IBD from HMM", y = "IBD from MLE")


```

_**Conceptual Question:** Why would these two results differ? Are there any differing assumptions made in the models?_
<br>
_**Example Answer:** Remember that `hmmIBD` assumes that samples are monoclonal. Therefore, heterozygote calls will break down IBD blocks rapidly under our simple "force" to monoclonal assumption_.
<br>
<br>

### Summary/Check-In
At this point, you should have created three R result objects:      
  + *ibs_long*     
  + *ibd_mle_long*     
  + *ibd_hmm_long*     
If you are having computational trouble or time is a limiting factor, please see the `results/` directory, where you will be able to read in the results.


# Applied IBD
In this section, we will focus on the utility of IBS and IBD for realistic applications related to control and elimination efforts. For this section, we will focus on the MLE-IBD estimates (vs HMM-IBD estimates).

## IBS vs IBD
Compare IBS and IBD in a scatterplot.
_**Code Challenge**_: Using the `geom_point` ggplot layer, create a plot that contrast the IBS estimations and the MLE IBD estimations. Add a regression line to explore the correlation using the `geom_smooth(aes(x = malecotf, y = ibsdist), method = "lm")` layer. Note,yYou will need to join the data by sample using the following function: `left_join(ibs_long, ibd_mle_long, by = c("p1", "p2"))` prior to using ggplot.
```{r}
dplyr::left_join(ibs_long, ibd_mle_long, by = c("p1", "p2")) %>%
  ggplot() +
  geom_point(aes(x = malecotf, y = ibsdist)) +
  geom_smooth(aes(x = malecotf, y = ibsdist), method = "lm") +
  xlim(c(0,1)) + ylim(c(0,1)) +
  labs(x = "MLE-IBD Estimates", y = "IBS Distance") +
  theme_bw()

```

_**Conceptual Question:** How do the estimates of IBS and IBD differ. What is the smallest value for IBS versus IBD? Why may these be different?_
<br>
_**Answer:** IBS is affected by the population allele frequencies in a population and can overestimate relatedness when alleles are fixed in a population due to reasons other than inheritance (i.e. IBD = 0, IBS > 0.5, seen on the left-hand side of the plot). Fixation of alleles is particularly common in small populations due to genetic drift (as was the case in this simulation) or due to selection. As a result, although high values of IBS likely indicate high levels of relatedness, lower values of IBS are more difficult to interpret._

## IBD Distribution
Now, let's look at the distribution of our IBD estimates. In particular, we will focus in on the "tail" of the distribution (_i.e._ high values). 
<br>
_**Code Challenge**_: Use the `geom_histogram` ggplot layer to reate a plot that shows the distribution of MLE IBD estimations. We will add an inset plot to explore the tail of this distribution. Explore this [blog](https://meghan.rbind.io/blog/cowplot/) to learn how to make plots with insets using the `cowplot` package. 
```{r}
mainplot <- ibd_mle_long %>%
  ggplot() +
  geom_histogram(aes(x=malecotf, y = (..count../sum(..count..))*100),
                 color = "#000000", fill = "#d9d9d9") +
  xlab("IBD") + ylab("frequency (%)") +
  theme_classic()

insetplot <- ibd_mle_long %>%
  ggplot() +
  geom_histogram(aes(x=malecotf, y = (..count../sum(..count..))*100),
                 color = "#000000", fill = "#d9d9d9") +
  xlab("IBD") + ylab("frequency (%)") +
  theme_classic() +
  coord_cartesian(xlim = c(0.5,1), ylim = c(0,0.8)) +
  theme_bw() +
  theme(panel.background = element_rect(fill = "transparent"),
        plot.background = element_rect(fill = "transparent"))
# cowplot
cowplot::ggdraw() +
  cowplot::draw_plot(mainplot, x = 0, y = 0, width = 1, height = 1, scale = 1) +
  cowplot::draw_plot(insetplot, x = 0.5, y= 0.3, width = 0.4, height = 0.4)

```
_**Conceptual Question:** How would you describe this distribution? Would you expect this many unrelated samples? What about the proportion of highly related pairs in the tail of the distribution?_
<br>
<br>

## Transmission Intensity
As we have seen from the recombination review at the beginning of the practical, as the number of recombination events increases, we expect for IBD due to decrease. As a result, in areas with higher transmission intensity, here modeled through differences in COI, we can expect for IBD to be less.

### Within-Deme IBD vs COI
By grouping samples together by their home demes, we can estimate the amount of inbreeding within a deme, or the within-deme IBD. Here, we will read in the `data/metadata.RDS` file and calculate the mean IBD by deme to get the within-deme IBD. We will then plot the within-deme IBD versus simulated mean COI.  
<br>  
<br>
_**Code Challenge part 1**_: Read in the metadata using the following code: `readRDS("data/metadata.RDS")`. Then combine our metadata to the `ibd_mle_long` dataframe using two different `left_join` calls. Note, you will need to make two different "metadata" dataframe with a column named "p1" (sample 1) and one wth a column named "p2" (sample 2). Rename the ".x" and ".y" extensions created by `left_join` to "_p1" and "_p2", respectively. 
After joining this data together, you should have a new dataframe with column names: `p1, p2, malectof, deme_p1, coimeans_p1, longnum_p1, latnum_p1, deme_p2, coimeans_pe2, longnum_p2, latnum_p2`. We are going to use this dataframe for the next few challenges, so please name it `ibd_mle_long_mtdt`.
<br>

```{r}
#......................
# part 1
#......................
mtdt <- readRDS("data/metadata.RDS")
# data munging
mtdt_x <- mtdt %>%
  dplyr::rename(p1 = smpl)
mtdt_y <- mtdt %>%
  dplyr::rename(p2 = smpl)
ibd_mle_long_mtdt <- dplyr::left_join(ibd_mle_long, mtdt_x, by = "p1") %>%
  dplyr::left_join(., mtdt_y, by = "p2") %>%
  rename_with(., ~gsub(".x", "_p1", .x, fixed = T)) %>%
  rename_with(., ~gsub(".y", "_p2", .x, fixed = T))
```
<br>
_**Conceptual Question:** Describe your new dataframe._
<br>
_**Answer:** We have a tidy long dataframe that contains pairwise comparisons contrasting sample one (p1) and sample two (p2) with corresponding metadata: deme, coi, GPS coordinates._
<br>
<br>
_**Code Challenge part 2**_: Calculate within-deme IBD. Now, subset your dataframe to only contain rows where pairwise comparisons are from the same deme: `dplyr::filter(deme_p1 == deme_p2)`. Group by demes (`group_by(deme_p1)`) and use the `summarise` function to calculate the mean within-deme IBD and the mean COI (note, COI is the same within a deme). Then use the `geom_point` layer in ggplot to contrast COI and within-deme IBD calculations. 
<br>
```{r}
#......................
# part 2: plot within IBD
#......................
ibd_mle_long_mtdt %>%
  dplyr::filter(deme_p1 == deme_p2) %>%
  dplyr::group_by(deme_p1) %>%
  dplyr::summarise(
    withinIBD = mean(malecotf),
    COI = unique(coimeans_p1)) %>%
  ggplot() +
  geom_point(aes(x = withinIBD, y = COI)) +
  labs(x = "Within Deme IBD", y = "Simulated Mean COI",
       caption = "Remember, COI is a poor estimate of incidence. IBD is also affected by multiple factors, including randomness.") +
  theme_classic()

```


_**Conceptual Question:** Is there a correlation here between mean COI and within deme IBD?_
<br>
_**Answer:** No, but the lowest COI was associated with the greatest within deme IBD._
<br>
<br>
_**Conceptual Question:** Why did our expectation of the relationship of within-deme IBD and transmission intensity not match reality?_
<br>
_**Answer:** Our expectations do not always match realized data. There are also multiple confounding variables here, including: migration and incomplete sampling._
<br>
<br>

## Isolation by Distance
Next, we will explore the concept of isolation by distance, which is the theory that as pairs move further away in space, they should be less related (_i.e._ closer pairs are more likely to reproduce). This concept is based on spatial relationships, but can also be conceptualized as time (pairs that are separated by multiple generations of time are less likely to be related).


_**Code Challenge part 1**_: Calculate [greater circle distance](https://en.wikipedia.org/wiki/Great-circle_distance). First, we will read in our pre-calculated GC distances: `readRDS(data/deme_gc_dist.RDS)`. Use a `left_join` call to merge this data while making a new dataframe called `ibd_mle_long_mtdt_dist`. Now, we will "bin" our distances by converting this continuous value into a discretized form using the `cut` function:
```
cut(x = c(ibd_mle_long_mtdt_dist$distance),
                                           breaks = c(0, 1e-26,
                                                      seq(40, 120, by = 40),
                                                      Inf),
                                           right = F, #
                                           labels = c("Within", "40km", "80km", "120km", ">120km"))
```
```{r}

#......................
# part 1
#......................
gcdist <- readRDS("data/deme_gc_dist.RDS")
ibd_mle_long_mtdt_dist <- dplyr::left_join(ibd_mle_long_mtdt, gcdist, by = c("deme_p1", "deme_p2")) %>%
  dplyr::mutate(distance = ifelse(is.na(distance), 0, distance))
ibd_mle_long_mtdt_dist$distance_cat <- cut(x = c(ibd_mle_long_mtdt_dist$distance),
                                           breaks = c(0, 1e-26,
                                                      seq(40, 120, by = 40),
                                                      Inf),
                                           right = F, #
                                           labels = c("Within", "40km", "80km", "120km", ">120km"))

```
<br>
_**Code Challenge part 2**_: Using our newly created dataframe, `ibd_mle_long_mtdt_dist`, group by the `distance_cat` column created with the `cut` function above and calculate the following summaries (`summarise`): mean IBD, standard deviation IBD, standard error IBD, lower 95% CI for IBD, and upper 95% CI for IBD. You can review the power practical, part 1 for a refresher on these statistics. 

```{r}
#......................
# part 2
#......................
plotdat <- ibd_mle_long_mtdt_dist %>%
  dplyr::group_by(distance_cat) %>%
  dplyr::summarise(
    n = n(),
    meanIBD = mean(malecotf),
    sdIBD = sd(malecotf),
    seIBD = sdIBD/sqrt(n),
    U95CI = meanIBD + 1.96 * seIBD,
    L95CI = meanIBD - 1.96 * seIBD) 
```
<br>

_**Code Challenge part 3**_: Using the `geom_pointrange` layer in ggplot, plot the mean IBD on the y-axis and the categorized GC distance on the x-axis. For the `geom_pointrange` aesthetics, you will need to specify: `y = meanIBD, ymin = L95CI, ymax = U95CI`. 

```{r}

#......................
# part 3
#......................
plotdat %>% 
  ggplot() +
  geom_pointrange(aes(x = distance_cat, y = meanIBD, ymin = L95CI, ymax = U95CI)) +
  scale_size(range = c(0, 1)) +
  labs(y = "Mean IBD", x = "GC Distance", title = "Isolation by Distance") +
  theme_classic() +
  theme(plot.title = element_text(family = "Helvetica", face = "bold", hjust = 0.5, size = 14),
        axis.title = element_text(family = "Helvetica", face = "bold", hjust = 0.5, size = 12))

```
<br>  
_**Conceptual Question:** How would you describe this relationship? Does it make sense?_
<br>
<br>

### Network Analysis
We can also use networks to determine the connectivity of our paired samples. Networks helps us visualize connections that we may not expect and are a useful tool for exploratory data analysis. Additionally, we can use [community detection algorithms](https://towardsdatascience.com/community-detection-algorithms-9bd8951e7dae) to explore which samples may "cluster" together based on relatedness. One way to conceptualize community detection algorithms is to consider that networks measure "popularity" and that samples that are "cliques" should cluster together. Alternatively, a sample may be "friends" with everyone and becomes very central or important to the network. These distinctions may be helpful to determine which demes are particularly connected and may be contributing to sink-source dynamics (see [Wesolowksi _et al._ 2018](https://pubmed.ncbi.nlm.nih.gov/30333020/) for further information on sink-source dynamics).
<br>
Read this STDHA [blog](http://sthda.com/english/articles/33-social-network-analysis/136-network-analysis-and-manipulation-using-r) networks and on community detection algorithms and use the R packages: [tidygraph](https://tidygraph.data-imaginist.com/index.html) and [ggraph](https://ggraph.data-imaginist.com/) to try to generate the figure below. 

_**Code Challenge**_: Use the `tidygraph::as_tbl_graph` function to convert our`ibd_mle_long` into an a `tbl_graph` for easier network analyses. Then calculate the compunity membership using `tidygraph::group_louvain(weights = malecotf)))` function and plot the resulting network with `ggraph::ggraph(layout = 'kk')`. Make sure to color in the nodes by community using the `geom_node_point` layer and proper aesthetic: `ggraph::geom_node_point(aes(color = community)`. 

```{r}
adj_graph <- ibd_mle_long %>%
  tidygraph::as_tbl_graph(., directed = F)

ibd_mle_long %>%
  tidygraph::as_tbl_graph(., directed = F) %>%
  dplyr::mutate(community = as.factor(tidygraph::group_louvain(weights = malecotf))) %>%
  tidygraph::activate("edges") %>%
  ggraph::ggraph(layout = 'kk') +
  ggraph::geom_edge_link(aes(width = malecotf,
                             color = malecotf)) +
  ggraph::geom_node_point(aes(color = community),
                          size = 3) +
  ggraph::scale_edge_width_continuous(range = c(0, 1), guide = "none") +
  ggraph::geom_node_text(aes(label = name), repel = T) +
  ggraph::scale_edge_color_viridis("IBD", values = c(0,1), option = "plasma") +
  scale_color_brewer(palette = "Set1") +
  ggraph::theme_graph() +
  theme(legend.position = "bottom")

```
_**Conceptual Question:** What do you notice about the above network? Are there any isolated cliques? Are there any very "popular" samples?_
<br>
<br>

## High Related Pairs
Here, we will subset to highly related pairs, defined as pairs that are at least meiotic siblings (_i.e._ share half of their genome). We will then map these between deme connections to determine if there is evidence of genetic sharing between demes. In this section, we will practice layering multiple dataframes onto a single plot. 

_**Code Challenge part 1**_: Here we will set up our data for making the map/plot. Read in the simulated map with the following function: `readRDS("data/sim_map_sf.RDS")`. Then make a condensed version of the metadata that just contains one row of coordinates for each deme. Next, make a dataframe containing highly related pairs between demes by subsetting the `ibd_mle_long_mtdt` to at least meiotic siblings: `dplyr::filter(malecotf >= 0.5)` and by excluding pairs that are from the same deme: ` dplyr::filter(deme_p1 != deme_p2)`. Finally, create a dataframe of demes that contain highly related pairs by subsetting the `ibd_mle_long_mtdt` to at least meiotic siblings: `dplyr::filter(malecotf >= 0.5)` and by including only pairs that are from the same deme: ` dplyr::filter(deme_p1 == deme_p2)`. You know have four objects ready for plotting: (1) map, (2) cluster locations, (3) highly related between deme pairs, (4) high related within deme pairs. 

```{r}
#......................
# part 1
#......................
# read in map base
simmap <- readRDS("data/sim_map_sf.RDS")
mtdtclst <- mtdt %>%
  dplyr::select(c("deme", "longnum", "latnum")) %>%
  dplyr::filter(!duplicated(.))

# find btwn sibs
highbtwnpairs <- ibd_mle_long_mtdt %>%
  dplyr::filter(malecotf >= 0.5) %>% 
  dplyr::filter(deme_p1 != deme_p2)

# find within
withinpairs <- ibd_mle_long_mtdt %>%
  dplyr::filter(malecotf >= 0.5) %>%
  dplyr::mutate(win = deme_p1 == deme_p2)
```


_**Code Challenge part 1**_: We will now plot these dataframes. First make a map base using the `geom_sf` layer. Next add a layer for cluster locations using `geom_point(data = mtdtclst, aes(x = longnum, y = latnum)`. Now we will color in the demes that contain highly related pairs within: `geom_point(data = withinpairs, aes(x = longnum_p1, y = latnum_p1), color = "blue"`. Finally, we will add a connections between pairs across different demes from our highly related between pairs dataframe: `geom_curve(data = highbtwnpairs, aes(x = longnum_p1, y = latnum_p1, xend = longnum_p2, yend = latnum_p2, color = malecotf)`. Your plot contains both spatial and relatedness data in a easily communicated graph. 
<br>
```{r}
# make plot
ggplot() +
  geom_sf(data = simmap) +
  geom_point(data = mtdtclst, aes(x = longnum, y = latnum),
             show.legend = F) +
  geom_point(data = withinpairs, aes(x = longnum_p1, y = latnum_p1),
             show.legend = F,
             color = "#0C73B2", shape = 15, size = 2) +
  geom_curve(data = highbtwnpairs,
             alpha = 0.5, size = 1.1,
             aes(x = longnum_p1, y = latnum_p1,
                 xend = longnum_p2, yend = latnum_p2,
                 color = malecotf), show.legend = F) +
  scale_color_viridis_c("Pairwise IBD", option="plasma", direction = 1, values = c(0,1)) +
  labs(caption = "Locations that contain highly related pairs within \n the deme are colored as blue squares; \n between deme connections are shown are curved lines") +
  theme_minimal() +
  theme(panel.grid = element_blank(),
        axis.title = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank())

```
<br>
<br>
_**Conceptual Question:** What can highly related pairs tell you? How do they relate to transmission events? Can you use them to estimate genetic corridors or evidence of gene flow? Do you think there is active transmission between the mainland and island (see original study hypothesis)?_
<br>
<br>


# Addendum {-}
Congratulations, you have reached the end of the practical. This section contains advanced material and additional resources for interested participants. If time permits, you can explore the advanced material challenge, the challenge questions, and/or the further readings. 

### Coding Challenges 
In this section, you will have the opportunity to explore and practice the skills above. 
<br>
Imagine that there are two populations: _A_ and _B_ with similar levels of falciparum incidence. However, there are only enough public health funds to intervene on one population. You have been asked by your National Malaria Control Programme (NMCP) to determine which population to intervene on. You first conduct a "travel survey" and determine that there are a high number of people that travel from _A_ to _B_. As a result, you hypothesis that _A_ is a "source" for _B_. Using the _VCF_ below, create a series of figure that you would present to your NMCP to encourage them to interview on population _A_ instead of _B_. Make sure to calculate IBD with multiple approaches to confirm your results. 
<br>
```{r}
# participants DO NOT need to include the quiet bit
ssvcf <- quiet(vcfR::read.vcfR("data/simulated_sink_source_ibd.vcf.gz"))
```
<br>
When finished with your figures, please ask an instructor for feedback. 
<br>


### Conceptual Challenges 
#### IBS & Polyclonality
Recently, [Tessema & Wesolowski et al. 2021](https://elifesciences.org/articles/43510) defined IBS for polyclonal samples as the proportion of sites that are identical divided by the potential alleles in all strains. Specifically, this can be expressed as for a pair of samples, $X$ and $Y$, the total number of shared alleles $S_{i}$ across the two samples divided by all alleles at that locus for sample $X$, $X_{i}$ and all alleles at that locus for sample $Y$, $Y_{i}$. This can be summed across all loci to produce an overall estimate of IBS.

$$IBS = \frac{1}{n} \sum_{i=1}^{n} \frac{S_{i}} {X_{i}Y_{i}} $$

<br>
<br>
_**Challenge Question:** Can you think of a different approach to calculating IBS accounting for IBS that accounts for within-sample IBD? How woud you begin to account for this? Please share your answer with an instructor!_
<br>
<br>

#### IBD & Polyclonality
As was described in the case of `hmmIBD`, polyclonality greatly complicates IBD estimates and is an active area of research. Recent solutions include considering the malaria genome as diploid, which allows for heterozygous alleles: [`isoRelate`](https://github.com/bahlolab/isoRelate) or phasing polyclonal infections and estimating IBD from the resultant haplotypes: [deploidIBD](https://github.com/DEploid-dev/DEploid). This is an active area of research and remains a challenge within the malaria genomic epidemiology field.   

<br>
<br>
_**Challenge Question:** How would you approach calculating IBD in a high-transmission region with numerous likely polyclonal infections? What advantages are there to phasing data? Please share your answer with an instructor!_
<br>
<br>
_**Challenge Question:** How would would the IBD estimates above change if you used [`isoRelate`](https://github.com/bahlolab/isoRelate). Try to use the program to determine if your hypotheses are correct._
<br>
<br>

### Further Reading 
#### HMMs

Hidden Markov models (HMMs) are a common statistical approach in population genetics, and for detecting IBD. For further reading, see [Rabiner 1989](https://web.mit.edu/6.435/www/Rabiner89.pdf).  
<br>
<br>

#### Coalescent Theory

Coalescent theory is one of the central pillars of population genetics and provides a framework for how loci (genes, individuals, etc.) have been derived from a common ancestor backwards in time, classically using the assumptions of the Wright-Fisher model. One of the main assumptions of the coalescence, is that loci are independent and that no recombination is occurring between loci. To relax this assumption, we must consider the coalescence with recombination. In this framework, a single coalescent tree is no longer representative of the genome (*NB*: genomes are now combination of genes on intervals [0, L) ; [L, L\_{+1}], see [Griffiths & Marjoram 1996](http://lamastex.org/recomb/ima.pdf) for further details). As a result, each loci in the gene interval has a marginal tree due recombination resulting in different genealogical histories of loci. The collection of these trees with respect to recombination breakpoints among loci in the gene interval is termed the Ancestral Recombination Graph (ARG). Relatedness is considered as the time to most recent common ancestor (TMRCA) for a given loci and gives a more refined estimate of relatedness versus the binary distinction of whether or not a specific segment of the genome is IBD (*as discussed in our lecture*).

<p align="center">

![ARG for Three Samples with Two Discrete Loci](https://raw.githubusercontent.com/mrc-ide/AMMS2022/master/IBD/R_ignore/images/arg.png){width="500px"}

<br>

The following are an excellent launching point:   
[Wakeley: Coalescent Theory: An Introduction](https://www.amazon.com/Coalescent-Theory-Introduction-John-Wakeley/dp/0974707759)\
[Li & Stephens: 2003 PSMC](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC1462870/)\
[Li & Durbin: 2011 PSMC](https://pubmed.ncbi.nlm.nih.gov/21753753/)
